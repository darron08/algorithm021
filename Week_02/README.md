# 哈希表

底层数据结构可能是哈希表或二叉树



## 解决哈希碰撞的常用办法

1. 链表法
2. 开放寻址法



## 时间复杂度

search O(1)

insertion O(1)

deletion O(1)



## 空间复杂度

O(n)



# 树 tree

树和图的最大差别就是有没有环，有环就是图

链表是特殊化的树

树是特殊化的图 



## 二叉树遍历

1. 前序（pre-order）：根左右
2. 中序（in-order）：左右根
3. 后续（post-order）：左右根



## 二叉搜索树 binary search tree

1. 左子树上所有结点的值均小于它的根结点的值；
2. 右子树上所有结点的值均大于它的根结点的值；
3. 以此类推：左右子树也分别是二叉搜索树（重复性）



它的中序遍历是升序排序



### 时间复杂度

access O(logn)

search O(logn)

insertion O(logn)

deletion O(logn)



二叉搜索树删除操作，如果删除的不是叶子结点，那么要在大于这个结点的结点中找到一个**最小的**，代替它的位置



# 堆 heap

可以迅速找到一堆数中的最大值或者最小值的数据结构

根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或者小根堆。

常见的堆有二叉堆，斐波那契堆。

二叉堆是堆（优先队列priority queue）的一种常见且简单的实现，但并不是最优的实现；工程上一般用斐波那契堆。

不同实现的比较： <https://en.wikipedia.org/wiki/Heap_(data_structure)>



## 大顶堆常见操作的时间复杂度

find-max O(1)

delete-max O(logn)

insert(或create) O(logn)或O(1)



## 二叉堆

通过完全二叉树来实现

二叉堆（大顶）满足以下性质：

1. 是一棵完全树
2. 树中任意节点的值总是大于等于其子节点的值



### 实现细节

一般都通过“数组”来实现

假设“第一个元素”在数组中的索引为0的话，则父节点和子节点的位置关系如下：

1. 索引为i的左孩子的索引是2*i+1
2. 索引为i的右孩子的索引是2*i+2
3. 索引为i的父节点的索引是floor((i-1)/2)



### insert 插入操作

1. 新元素一律先插入到堆的尾部
2. 依次向上调整整个堆的结构（一直到根即可），称作heapifyup



### delete max 删除堆顶操作

1. 将堆尾元素替换到顶部（即堆顶被替代删除掉）
2. 依次从根部向下调整整个堆的结构（一直到堆尾即可），称作heapifydown